/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_VFIO_USER_GENERATED_TRACERS_H
#define TRACE_HW_VFIO_USER_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VFIO_USER_RECV_HDR_EVENT;
extern TraceEvent _TRACE_VFIO_USER_RECV_READ_EVENT;
extern TraceEvent _TRACE_VFIO_USER_RECV_REQUEST_EVENT;
extern TraceEvent _TRACE_VFIO_USER_SEND_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_USER_VERSION_EVENT;
extern TraceEvent _TRACE_VFIO_USER_GET_INFO_EVENT;
extern TraceEvent _TRACE_VFIO_USER_GET_REGION_INFO_EVENT;
extern TraceEvent _TRACE_VFIO_USER_REGION_RW_EVENT;
extern TraceEvent _TRACE_VFIO_USER_GET_IRQ_INFO_EVENT;
extern TraceEvent _TRACE_VFIO_USER_SET_IRQS_EVENT;
extern TraceEvent _TRACE_VFIO_USER_WRMULTI_EVENT;
extern TraceEvent _TRACE_VFIO_USER_DMA_MAP_EVENT;
extern TraceEvent _TRACE_VFIO_USER_DMA_UNMAP_EVENT;
extern uint16_t _TRACE_VFIO_USER_RECV_HDR_DSTATE;
extern uint16_t _TRACE_VFIO_USER_RECV_READ_DSTATE;
extern uint16_t _TRACE_VFIO_USER_RECV_REQUEST_DSTATE;
extern uint16_t _TRACE_VFIO_USER_SEND_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_USER_VERSION_DSTATE;
extern uint16_t _TRACE_VFIO_USER_GET_INFO_DSTATE;
extern uint16_t _TRACE_VFIO_USER_GET_REGION_INFO_DSTATE;
extern uint16_t _TRACE_VFIO_USER_REGION_RW_DSTATE;
extern uint16_t _TRACE_VFIO_USER_GET_IRQ_INFO_DSTATE;
extern uint16_t _TRACE_VFIO_USER_SET_IRQS_DSTATE;
extern uint16_t _TRACE_VFIO_USER_WRMULTI_DSTATE;
extern uint16_t _TRACE_VFIO_USER_DMA_MAP_DSTATE;
extern uint16_t _TRACE_VFIO_USER_DMA_UNMAP_DSTATE;
#define TRACE_VFIO_USER_RECV_HDR_ENABLED 1
#define TRACE_VFIO_USER_RECV_READ_ENABLED 1
#define TRACE_VFIO_USER_RECV_REQUEST_ENABLED 1
#define TRACE_VFIO_USER_SEND_WRITE_ENABLED 1
#define TRACE_VFIO_USER_VERSION_ENABLED 1
#define TRACE_VFIO_USER_GET_INFO_ENABLED 1
#define TRACE_VFIO_USER_GET_REGION_INFO_ENABLED 1
#define TRACE_VFIO_USER_REGION_RW_ENABLED 1
#define TRACE_VFIO_USER_GET_IRQ_INFO_ENABLED 1
#define TRACE_VFIO_USER_SET_IRQS_ENABLED 1
#define TRACE_VFIO_USER_WRMULTI_ENABLED 1
#define TRACE_VFIO_USER_DMA_MAP_ENABLED 1
#define TRACE_VFIO_USER_DMA_UNMAP_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_VFIO_USER_RECV_HDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_RECV_HDR) || \
    false)

static inline void _nocheck__trace_vfio_user_recv_hdr(const char * name, uint16_t id, uint16_t cmd, uint32_t size, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VFIO_USER_RECV_HDR) && qemu_loglevel_mask(LOG_TRACE)) {
#line 6 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_recv_hdr " " (%s) id 0x%x cmd 0x%x size 0x%x flags 0x%x" "\n", name, id, cmd, size, flags);
#line 60 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_recv_hdr(const char * name, uint16_t id, uint16_t cmd, uint32_t size, uint32_t flags)
{
    if (true) {
        _nocheck__trace_vfio_user_recv_hdr(name, id, cmd, size, flags);
    }
}

#define TRACE_VFIO_USER_RECV_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_RECV_READ) || \
    false)

static inline void _nocheck__trace_vfio_user_recv_read(uint16_t id, int read)
{
    if (trace_event_get_state(TRACE_VFIO_USER_RECV_READ) && qemu_loglevel_mask(LOG_TRACE)) {
#line 7 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_recv_read " " id 0x%x read 0x%x" "\n", id, read);
#line 80 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_recv_read(uint16_t id, int read)
{
    if (true) {
        _nocheck__trace_vfio_user_recv_read(id, read);
    }
}

#define TRACE_VFIO_USER_RECV_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_RECV_REQUEST) || \
    false)

static inline void _nocheck__trace_vfio_user_recv_request(uint16_t cmd)
{
    if (trace_event_get_state(TRACE_VFIO_USER_RECV_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
#line 8 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_recv_request " " command 0x%x" "\n", cmd);
#line 100 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_recv_request(uint16_t cmd)
{
    if (true) {
        _nocheck__trace_vfio_user_recv_request(cmd);
    }
}

#define TRACE_VFIO_USER_SEND_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_SEND_WRITE) || \
    false)

static inline void _nocheck__trace_vfio_user_send_write(uint16_t id, int wrote)
{
    if (trace_event_get_state(TRACE_VFIO_USER_SEND_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
#line 9 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_send_write " " id 0x%x wrote 0x%x" "\n", id, wrote);
#line 120 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_send_write(uint16_t id, int wrote)
{
    if (true) {
        _nocheck__trace_vfio_user_send_write(id, wrote);
    }
}

#define TRACE_VFIO_USER_VERSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_VERSION) || \
    false)

static inline void _nocheck__trace_vfio_user_version(uint16_t major, uint16_t minor, const char * caps)
{
    if (trace_event_get_state(TRACE_VFIO_USER_VERSION) && qemu_loglevel_mask(LOG_TRACE)) {
#line 10 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_version " " major %d minor %d caps: %s" "\n", major, minor, caps);
#line 140 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_version(uint16_t major, uint16_t minor, const char * caps)
{
    if (true) {
        _nocheck__trace_vfio_user_version(major, minor, caps);
    }
}

#define TRACE_VFIO_USER_GET_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_GET_INFO) || \
    false)

static inline void _nocheck__trace_vfio_user_get_info(uint32_t nregions, uint32_t nirqs)
{
    if (trace_event_get_state(TRACE_VFIO_USER_GET_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
#line 11 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_get_info " " #regions %d #irqs %d" "\n", nregions, nirqs);
#line 160 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_get_info(uint32_t nregions, uint32_t nirqs)
{
    if (true) {
        _nocheck__trace_vfio_user_get_info(nregions, nirqs);
    }
}

#define TRACE_VFIO_USER_GET_REGION_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_GET_REGION_INFO) || \
    false)

static inline void _nocheck__trace_vfio_user_get_region_info(uint32_t index, uint32_t flags, uint64_t size)
{
    if (trace_event_get_state(TRACE_VFIO_USER_GET_REGION_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
#line 12 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_get_region_info " " index %d flags 0x%x size 0x%"PRIx64 "\n", index, flags, size);
#line 180 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_get_region_info(uint32_t index, uint32_t flags, uint64_t size)
{
    if (true) {
        _nocheck__trace_vfio_user_get_region_info(index, flags, size);
    }
}

#define TRACE_VFIO_USER_REGION_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_REGION_RW) || \
    false)

static inline void _nocheck__trace_vfio_user_region_rw(uint32_t region, uint64_t off, uint32_t count)
{
    if (trace_event_get_state(TRACE_VFIO_USER_REGION_RW) && qemu_loglevel_mask(LOG_TRACE)) {
#line 13 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_region_rw " " region %d offset 0x%"PRIx64" count %d" "\n", region, off, count);
#line 200 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_region_rw(uint32_t region, uint64_t off, uint32_t count)
{
    if (true) {
        _nocheck__trace_vfio_user_region_rw(region, off, count);
    }
}

#define TRACE_VFIO_USER_GET_IRQ_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_GET_IRQ_INFO) || \
    false)

static inline void _nocheck__trace_vfio_user_get_irq_info(uint32_t index, uint32_t flags, uint32_t count)
{
    if (trace_event_get_state(TRACE_VFIO_USER_GET_IRQ_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
#line 14 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_get_irq_info " " index %d flags 0x%x count %d" "\n", index, flags, count);
#line 220 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_get_irq_info(uint32_t index, uint32_t flags, uint32_t count)
{
    if (true) {
        _nocheck__trace_vfio_user_get_irq_info(index, flags, count);
    }
}

#define TRACE_VFIO_USER_SET_IRQS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_SET_IRQS) || \
    false)

static inline void _nocheck__trace_vfio_user_set_irqs(uint32_t index, uint32_t start, uint32_t count, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VFIO_USER_SET_IRQS) && qemu_loglevel_mask(LOG_TRACE)) {
#line 15 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_set_irqs " " index %d start %d count %d flags 0x%x" "\n", index, start, count, flags);
#line 240 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_set_irqs(uint32_t index, uint32_t start, uint32_t count, uint32_t flags)
{
    if (true) {
        _nocheck__trace_vfio_user_set_irqs(index, start, count, flags);
    }
}

#define TRACE_VFIO_USER_WRMULTI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_WRMULTI) || \
    false)

static inline void _nocheck__trace_vfio_user_wrmulti(const char * s, uint64_t wr_cnt)
{
    if (trace_event_get_state(TRACE_VFIO_USER_WRMULTI) && qemu_loglevel_mask(LOG_TRACE)) {
#line 16 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_wrmulti " " %s count 0x%"PRIx64 "\n", s, wr_cnt);
#line 260 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_wrmulti(const char * s, uint64_t wr_cnt)
{
    if (true) {
        _nocheck__trace_vfio_user_wrmulti(s, wr_cnt);
    }
}

#define TRACE_VFIO_USER_DMA_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_DMA_MAP) || \
    false)

static inline void _nocheck__trace_vfio_user_dma_map(uint64_t iova, uint64_t size, uint64_t off, uint32_t flags, bool async_ops)
{
    if (trace_event_get_state(TRACE_VFIO_USER_DMA_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
#line 19 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_dma_map " " iova 0x%"PRIx64" size 0x%"PRIx64" off 0x%"PRIx64" flags 0x%x async_ops %d" "\n", iova, size, off, flags, async_ops);
#line 280 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_dma_map(uint64_t iova, uint64_t size, uint64_t off, uint32_t flags, bool async_ops)
{
    if (true) {
        _nocheck__trace_vfio_user_dma_map(iova, size, off, flags, async_ops);
    }
}

#define TRACE_VFIO_USER_DMA_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VFIO_USER_DMA_UNMAP) || \
    false)

static inline void _nocheck__trace_vfio_user_dma_unmap(uint64_t iova, uint64_t size, uint32_t flags, bool async_ops)
{
    if (trace_event_get_state(TRACE_VFIO_USER_DMA_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
#line 20 "../hw/vfio-user/trace-events"
        qemu_log("vfio_user_dma_unmap " " iova 0x%"PRIx64" size 0x%"PRIx64" flags 0x%x async_ops %d" "\n", iova, size, flags, async_ops);
#line 300 "trace/trace-hw_vfio_user.h"
    }
}

static inline void trace_vfio_user_dma_unmap(uint64_t iova, uint64_t size, uint32_t flags, bool async_ops)
{
    if (true) {
        _nocheck__trace_vfio_user_dma_unmap(iova, size, flags, async_ops);
    }
}
#endif /* TRACE_HW_VFIO_USER_GENERATED_TRACERS_H */
